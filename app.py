import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_squared_error
import random

# Set page layout to wide
st.set_page_config(layout="wide")

# Score Counter
if "score" not in st.session_state:
    st.session_state.score = 0

# Only the styled score display in the sidebar
st.sidebar.markdown(
    f"""
    <div style="display: flex; justify-content: center; align-items: center; 
                border: 2px solid black; padding: 10px; margin: 20px 0;">
        <h1 style="font-size: 50px; font-weight: bold; text-decoration: underline; 
                   margin: 0;">Score: {st.session_state.score}</h1>
    </div>
    """,
    unsafe_allow_html=True
)

# Title and Game Instructions
st.title("MA103 Data Fitting Challenge")
st.write("""
    Welcome to the **Data Fitting Challenge**! Each scenario is generated by changing the number at the top of the sidebar. 
    Select the "best" model and adjust parameters to fit the generated data, then click **Plot Model**. 
    Fine-tune the model using the sliders until the displayed error metrics indicate a close fit. 
    Each time you reach a close enough fit (NRMSE threshold), you'll earn **10 points**! 
    Track each data set by recording the problem number, selected model, and your parameter settings.
    Try to fit as many data sets as possible within the time limit to win! 
    _(Feel free to skip data situations that seem too challenging.)_
""")

# Sidebar for score and data generation options
st.sidebar.header("Data Generation Options")
seed = st.sidebar.number_input("Enter a problem number:", value=0, step=1)

# Check if seed has changed, and reset states if it has
if "last_seed" not in st.session_state or st.session_state.last_seed != seed:
    st.session_state.show_model = False
    st.session_state.model_choice = "Select Model Method"
    st.session_state.last_seed = seed
    st.session_state.points_awarded = False  # Reset points_awarded for each new problem

# Set seed for reproducible data generation
random.seed(seed)
np.random.seed(seed)

# Generate random function type and parameters based on seed
function_type = random.choice(["Exponential", "Power", "Trigonometric"])
x = np.linspace(0, 10, 100)

# Exponential Data Generation with Dynamic Noise Scaling
if function_type == "Exponential":
    a = np.round(random.uniform(-2.0, 2.0), 2)  # Slightly larger range for variety
    b = np.round(random.uniform(0.1, 1.5), 2)  # Lowered upper bound to avoid explosive growth
    d = np.round(random.uniform(-20,20), 2) # Vertical shift up or down
    base = random.choice([0.5, 1.5, 2, np.e])  # Random base choice for variety
    y_true = a * np.power(base, b * x) + d
    noise_level = 0.1 * (1 + b) * y_true.std()  # Dynamic noise based on growth rate
    y_noisy = y_true + noise_level * np.random.normal(size=x.size)

elif function_type == "Power":
    a = np.round(random.uniform(-5.0, 5.0), 2)
    b = np.round(random.uniform(0.01, 5.0), 2)
    d = np.round(random.uniform(-20,20), 2) # Vertical shift up or down
    y_true = a * np.power(x, b)
    noise_level = 20  # Moderate noise level for power

elif function_type == "Trigonometric":
    amplitude = np.round(random.uniform(-5.0, 5.0), 2)
    frequency = np.round(random.uniform(0.1, 2.0), 2)
    phase_shift = np.round(random.uniform(0.0, 2 * np.pi), 2)
    y_true = amplitude * np.sin(frequency * x + phase_shift)
    noise_level = 0.3  # Moderate noise level for trigonometric

# Add noise to synthetic data
y_noisy = y_true + noise_level * np.random.normal(size=x.size)

# Sidebar model selection and parameter inputs
st.sidebar.header("Model Fitting")
model_choice = st.sidebar.selectbox("Select the Model Type to Fit", ["Select Model Method", "Exponential", "Power", "Trigonometric"], key="model_choice")

# Set up parameters and display equation based on model selection
if model_choice == "Exponential":
    base_est = st.sidebar.radio("Select Base", options=[0.5, 1.5, 2, np.e], format_func=lambda x: f"{x:.2f}" if x != np.e else "e")
    a_est = st.sidebar.slider("Base Multiplier (a)", -2.0, 2.0, 0.5)
    b_est = st.sidebar.slider("Growth Rate (b)", 0.1, 2.0, 0.5)
    d_est = st.sidebar.slider("Vertical Shift (d)", -20.0, 20.0, 0.0, step=0.1)
    if st.sidebar.button("Plot Model") or st.session_state.show_model:
        y_pred = a_est * np.power(base_est, b_est * x)+d_est
        st.session_state.show_model = True
        base_display = f"{base_est:.2f}" if base_est != np.e else "e"
        if d_est > 0:
            vert = f" + {d_est:.2f}"
        elif d_est < 0:
            vert = f" {d_est:.2f}"
        else:
            vert = ""
        st.sidebar.latex(r"y = " + f"{a_est:.2f}" + r" \cdot " + base_display + r"^{" + f"{b_est:.2f}" + r" x}" + vert)

elif model_choice == "Power":
    a_est = st.sidebar.slider("Coefficient (a)", -5.0, 5.0, 1.5)
    b_est = st.sidebar.slider("Exponent (b)", 0.01, 5.0, 1.0)
    d_est = st.sidebar.slider("Vertical Shift (d)", -20.0, 20.0, 0.0, step=0.1)
    if st.sidebar.button("Plot Model") or st.session_state.show_model:
        y_pred = a_est * np.power(x, b_est) + d_est
        st.session_state.show_model = True
        if d_est > 0:
            vert = f" + {d_est:.2f}"
        elif d_est < 0:
            vert = f" {d_est:.2f}"
        else:
            vert = ""
        st.sidebar.latex(r"y = " + f"{a_est:.2f}" + r" \cdot x^{" + f"{b_est:.2f}" + r"}" + vert)

elif model_choice == "Trigonometric":
    amplitude_est = st.sidebar.slider("Amplitude", -5.0, 5.0, 1.0)
    frequency_est = st.sidebar.slider("Frequency", 0.1, 2.0, 0.5)
    phase_shift_est = st.sidebar.slider("Phase Shift", 0.0, 2 * np.pi, 0.0)
    if st.sidebar.button("Plot Model") or st.session_state.show_model:
        y_pred = amplitude_est * np.sin(frequency_est * x + phase_shift_est)
        st.session_state.show_model = True
        st.sidebar.latex(r"y = " + f"{amplitude_est:.2f}" + r" \cdot \sin(" + f"{frequency_est:.2f}" + r" x + " + f"{phase_shift_est:.2f}" + r")")

# Plot generated noisy data and, if selected, current model prediction on the same chart
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(x, y_noisy, 'o', label="Noisy Data")
if st.session_state.show_model and model_choice != "Select Model Method":
    ax.plot(x, y_pred, '-', label="Fitted Model", color='red')
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.legend()
st.pyplot(fig)

# Initialize points_awarded in session state if not already done
if "points_awarded" not in st.session_state:
    st.session_state.points_awarded = False

# Check if seed has changed, and reset states if it has
if "last_seed" not in st.session_state or st.session_state.last_seed != seed:
    st.session_state.show_model = False
    st.session_state.model_choice = "Select Model Method"
    st.session_state.last_seed = seed
    st.session_state.points_awarded = False  # Reset points_awarded for each new problem

# Initialize completed problems list in session state if not already done
if "completed_problems" not in st.session_state:
    st.session_state.completed_problems = []

# Display error metrics and award points if the model is a close enough fit
if st.session_state.show_model and model_choice != "Select Model Method":
    mad = mean_absolute_error(y_noisy, y_pred)
    mse = mean_squared_error(y_noisy, y_pred)

    # Calculate NRMSE for scaled error
    range_y = y_noisy.max() - y_noisy.min()
    nrmse = np.sqrt(mean_squared_error(y_noisy, y_pred)) / range_y
    nrmse_threshold = 0.1  # Adjust this threshold as needed

    st.write("### Error Metrics")
    st.write(f"Mean Absolute Deviation (MAD): {mad:.4f}")
    st.write(f"Mean Squared Error (MSE): {mse:.4f}")
    st.write(f"Normalized Root Mean Squared Error (NRMSE): {nrmse:.4f}")

    # Check if the model fit is close enough, and award points only if not previously awarded and not completed
    if nrmse < nrmse_threshold and not st.session_state.points_awarded:
        if seed not in st.session_state.completed_problems:
            st.session_state.score += 10            # Increment the score
            st.session_state.completed_problems.append(seed)  # Add to completed problems
            st.session_state.points_awarded = True  # Set points_awarded to True to prevent double counting
            st.balloons()  # Trigger celebration effect
        else:
            st.write("### You've already completed this problem! Try a new one to score points.")
        
        st.write("### Correct Answer")
        if function_type == "Exponential":
            # Display the correct exponential model in LaTeX with parameters a, b, and base
            base_display = f"{base:.2f}" if base != np.e else "e"
            st.write(f"The correct model is **Exponential** with parameters a = {a}, b = {b}, and base = {base_display}.")
            st.latex(r"y = " + f"{a:.2f}" + r" \cdot " + base_display + r"^{" + f"{b:.2f}" + r" x}")

        elif function_type == "Power":
            # Display the correct power model in LaTeX with parameters a and b
            st.write(f"The correct model is **Power** with parameters a = {a} and b = {b}.")
            st.latex(r"y = " + f"{a:.2f}" + r" \cdot x^{" + f"{b:.2f}" + r"}")

        elif function_type == "Trigonometric":
            # Display the correct trigonometric model in LaTeX with amplitude, frequency, and phase shift
            st.write(f"The correct model is **Trigonometric** with parameters amplitude = {amplitude}, frequency = {frequency}, and phase shift = {phase_shift}.")
            st.latex(r"y = " + f"{amplitude:.2f}" + r" \cdot \sin(" + f"{frequency:.2f}" + r" x + " + f"{phase_shift:.2f}" + r")")

# Reset points_awarded state with new seed
if "points_awarded" in st.session_state and st.session_state.last_seed != seed:
    st.session_state.points_awarded = False

# Add the "Help on Parameters" section below the main content
st.markdown("---")  # Horizontal line for separation
st.header("Help on Parameters")

# Dropdown to select model type for help with a placeholder
model_help_choice = st.selectbox("Select Model Type for Help", ["", "Exponential", "Power", "Trigonometric"], format_func=lambda x: "Select a Model" if x == "" else x)


# Define explanations for each model type
if model_help_choice == "Exponential":
    st.latex(r"y = a \cdot b^{c \cdot x}")
    st.write("""
        **Exponential Model:**
        
        - **Base Multiplier (a):** This parameter scales the initial value of the model. A larger \(a\) will make the starting value of \(y\) higher, and a smaller \(a\) will lower it.
        
        - **Base (b):** The base determines the rate of growth or decay. When \( b > 1 \), the model represents exponential growth, and when \( 0 < b < 1 \), it represents exponential decay.
        
        - **Growth Rate (c):** This parameter controls the rate at which \( y \) grows or decays. A larger \( c \) results in a faster growth or decay rate, while a smaller \( c \) slows down the growth or decay. If \( c \) is negative, the model represents decay, regardless of the base.
    """)

elif model_help_choice == "Power":
    st.latex(r"y = a \cdot x^{b}")
    st.write("""
        **Power Model:**
        
        - **Coefficient (a):** This parameter controls the overall scale of the model. A larger \(a\) will make the values of \(y\) higher, while a smaller \(a\) reduces them.
        
        - **Exponent (b):** This parameter dictates how sharply the curve increases or decreases. When \( b > 1 \), the model represents accelerated growth; when \( 0 < b < 1 \), it represents a more gradual growth (sublinear).
    """)

elif model_help_choice == "Trigonometric":
    st.latex(r"y = a \cdot \sin(b (x - c))")
    st.write("""
        **Trigonometric Model:**
        
        - **Amplitude (a):** This parameter controls the peak height of the sine wave. A larger \(a\) increases the wave's height, while a smaller \(a\) decreases it.
        
        - **Frequency (b):** This parameter affects the frequency of oscillations. A higher \(b\) results in more cycles within a given interval, making the wave oscillate faster. A lower \(b\) makes it oscillate more slowly.
        
        - **Phase Shift (c):** This parameter shifts the wave horizontally. Positive values of \(c\) shift the wave to the left, while negative values shift it to the right.
    """)


st.markdown("---")  # Horizontal line for separation
c1, _ = st.columns([1,6])
with c1:
    password = st.text_input('Data-Generating Model: ')
if password == "modeling":
    if function_type == "Exponential":
        # Display the correct exponential model in LaTeX with parameters a, b, and base
        base_display = f"{base:.2f}" if base != np.e else "e"
        st.write(f"The correct model is **Exponential** with parameters a = {a}, b = {b}, and base = {base_display}.")
        st.latex(r"y = " + f"{a:.2f}" + r" \cdot " + base_display + r"^{" + f"{b:.2f}" + r" x}")

    elif function_type == "Power":
        # Display the correct power model in LaTeX with parameters a and b
        st.write(f"The correct model is **Power** with parameters a = {a} and b = {b}.")
        st.latex(r"y = " + f"{a:.2f}" + r" \cdot x^{" + f"{b:.2f}" + r"}")

    elif function_type == "Trigonometric":
        # Display the correct trigonometric model in LaTeX with amplitude, frequency, and phase shift
        st.write(f"The correct model is **Trigonometric** with parameters amplitude = {amplitude}, frequency = {frequency}, and phase shift = {phase_shift}.")
        st.latex(r"y = " + f"{amplitude:.2f}" + r" \cdot \sin(" + f"{frequency:.2f}" + r" x + " + f"{phase_shift:.2f}" + r")")
